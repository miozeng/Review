
# Java内存区域
Java虚拟机在执行java程序的过程中会把他所管理的内存划分为若干个不同的数据区域

## 2.程序计数器：
Jvm将这个计数看作当前线程执行某条字节码的行数，会根据计数器的值来选取需要执行的操作语句。这个属于线程私有，不可共享，如果共享会导致计数混乱，无法准确的执行当前线程需要执行的语句。该区域不会出现任何OutOfMemoryError的情况。

## 3.虚拟机栈
经常说到的栈内存就是指虚拟机栈。Java中每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。虚拟机栈描述的是java方法中执行的内存模型，每个方法被执行的时候都会同时创建一个栈针，用于存储变量表、操作栈、动态链表、方法出口等。   
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。    

## 4.本地方法栈
虚拟机栈用来执行java方法，而本地方法栈用来执行本地方法。
抛出异常的情况和虚拟机栈一样。
## 5.堆
是jvm中内存最大、线程共享的一块区域。唯一的目的是存储对象实例。这里也是垃圾收集器主要收集的区域。由于现代垃圾收集器都采用的是分代收集算法，所以java堆也分为新生代和老年代。再细致一点的有eden空间、fromsurvivor空间、tofromsurvivor空间。   
可以通过参数-Xmx(jvm最大可用内存)和-Xms(jvm初始内存)来调整堆内存，如果扩大至无法继续扩展时，会出现OutOfMemoryError的错误。
## 6.方法区
Jvm中内存共享的一片区域，用来存储类信息、常量、静态变量、class文件。垃圾收集器也会对这部分区域进行回收，比如常量池的清理和类型的卸载，但是效果不理想。
     方法区内存不够用的时候，也会抛出OutOfMemoryError错误。
附加信息   
A.运行时常量池   
运行时常量池是方法区的一部分，class文件除了有版本、字段、方法、接口等描述信息以外，还有一项信息是常量池，用户存储编译期生成的各种字面量和符号引用，这部分内容将在内加载后存放在运行时常量池中。
    
B.直接内存   
直接内存既不是虚拟机运行时数据区的一部分也不是java虚拟机规范中定义的内存区域，jdk1.4引入了NIO类，引入了一种基于通道与缓存区的I/O方式，他可以使用native函数库直接分配堆外内存，然后通过一个存储java堆里面的directByteBuffer对象作为这块内存的引用进行操作，

## 7. 对象创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，加载检查之后会在堆中划分出一定的内存。
在完成new指令之后，紧接着会调用<init>方法将对象初始化，这时一个完整的对象才算创建了出来。

## 8. 对象的访问
1.句柄式      
如果使用句柄式，java堆中会出现一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含的对象实例数据和类型数据各自的具体地址信息。（reference中存储的是稳定的句柄地址，在对象移动时只会改变句柄中的实例数据指针而reference本身不被修改）

2.直接指针访问方式   
java堆对象在布局中必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图（速度快节省了一次指针定位的时间开销）   
在sun的jdk中采用的是指针访问方式，在reference中直接存储了对象的地址。

## 9.OutOfMemoryError错误   
Java堆内存的OutOfMemoryError异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
通过内存映像分析工具，先分清楚是内存溢出还是内存泄漏，如果是内存泄漏，找到内存泄漏的位置，修改代码。   
如果是内存溢出，当产生的对象过多时，会出现这个错误信息。解决办法：调整虚拟机堆参数(-Xmx和-Xms)。   
Java方法区会存储类信息、常量、静态变量等。如果产生了大量类，比如某个ssh项目因为加载了框架和大量jar包，这样class文件都会载入内存的方法区，这样如果出现内存无法继续扩展的情况，也会出现java.lang.OutOfMemoryError，然后紧跟着PermGen space信息。通过-XX:PermSize和-XX:MaxPermSize可以限制方法区大小。

## 10.StackOverflow错误   
Java中栈内存溢出，通常是由于栈深度超过限制深度，导致出现该问题。（stackoverflowerror）很常见的情况是，使用递归的时候，不小心忘了指定递归结束的时刻，导致递归深度超过限制深度，出现栈内存溢出。
如果虚拟机在扩展栈时无法申请到足有的内存空间则抛出java.lang.OutOfMemoryError
注：32位的Windows操作系统给每个进程的最大内存是2G，除去最大java堆容量 xmx和最大方法区容量（maxpermSize），以及程序计数器，程序本身占用内存，剩下的才是栈所拥有的可以瓜分的内存，每个线程栈容量内存分配的越大，可建立的线程越少，建立线程时容易把剩下的内存用完。在虚拟机不能更换的情况下，通过减少其他内存（最大堆，栈容量等）来扩大栈内存，换取更多的线程。
运行时常量池异常
如果运行时常量池中添加内容最简单的方法是String.intern（），由于运行时常量池在方法区，所以可以通过调节方法区内存大小间接解决。

# 垃圾回收器与内存分配策略   
## 1.判断对象是否存活的算法
主流jvm虚拟机不会采用引用计数法，因为有种情况它无法判断是否存活。比如互成环路的几个对象，没有其他对象引用他们了，这样按道理来说是死对象，可以被回收，但是按照引用计数法的判定，他们计数还不为0，也就是还不能被回收。
主流商用jvm目前采用的是可达性算法（根搜索算法）。利用有向图的原理，从根节点（原点）GC ROOT可达的所有其他节点表示目前仍然被引用，无法被回收。而从它无法达到的对象节点（距离为∞）则表示该对象可以被回收。GC ROOT表示：虚拟机栈中引用指向的对象或者方法区中的常量对象和静态对象，或者jni（java本地方法）中引用的对象。
## 2.引用
引用代表的是数据A中存储了一个地址，这个地址指向另一快内存的起始地址，这个A就是一个引用。
强引用：无论何时都不会被回收。普遍存在，如Object o=new Object();
弱引用：当垃圾收集器工作时，就会回收弱引用指向的对象。
## 3.回收流程
回收时系统会执行System.gc()，找到不可达对象，标记该对象为待回收对象，并查看该对象是否覆盖finalize()方法，如果覆盖了并且该方法之前没有被调用过，然后将他放到一个队列中（F-QUEUE），排着长队等着finalize()回收。即使进入finalize()方法，也不能保证该方法可以回收对象，因为对象可以在该方法里面关联其他引用，完成自救。综合而言，finalize()每次执行消耗成本高，但不能保证回收对象，所以效果并不好，并不推荐手动调用finalize()方法。
## 4.垃圾收集算法
方法区一般是没用垃圾回收的，因为性价比低，而永久代主要回收对象包废弃常量和无用的类在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成jsp和OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。
主流jvm都采用分代收集算法（将java堆分而治之）：   
新生代：大量对象死亡，少量存活，采用复制算法  
老年代：少量死亡，大量存活，采用标记整理法或标记清除法  
 
### 复制算法：
将内存划分为两片区域A和B，每次都只占用A部分。这样A放了所有对象，B空着。每次收集的时候标记A中的存活部分，复制到B中，然后统一清除A中的内容即可。缺点：内存占用高！适用：新生代。新生代的实际使用并不是1:1分配，而是分为Eden一个较大的内存和两小块的survivor。然后将Eden和一块survivor上存活的对象放到另一块survivor上。
### 标记清除算法：
标记所有垃圾对象，完成标记后统一清除这些垃圾对象。缺点：效率低，产生碎片多。适用：老年代。
### 标记整理算法：
标记所有垃圾对象，将存活对象移动到一边，清掉另一边的垃圾对象。适用：老年代。   
吞吐量：运行用户代码时间/（运行用户代码时间+垃圾回收时间）  
## 垃圾回收器：
Serial（serial-old）收集器：单线程，垃圾回收时要停止线程的所有工作。直到他收集完。Serial收集器依然是运行在client模式下的默认新生代收集器。  
Parnew 收集器：多线程版其余跟serial类似，大部分用在server模式下。但是再单cpu的环境下效率绝对不会比serial高。  
Parallel scavenger（Parallel old） 也是一个新生代垃圾回收器，使用复制算法，他的关注点是颗控制得吞吐量。    
CMS回收器：以最短回收停顿时间为目标的收集器，大部分运用在B/S系统互联网网站等，基于标记-清除算法。整个过程分为四个步骤：初始标记、并发标记、重新标记、并发清除。但是cms对cpu资源非常敏感，无法处理浮动数据，标记-清楚算法产生大量空间碎片。   
G1回收器：基于标记-整理，jdk1.7正式使用，1.6试用，可以实现基本不牺牲吞吐量的前提下完成低停顿的内存回收。   

## 内存分配： 
大多数情况下对象在新生代eden中分配，当eden没有足够的空间进行分配时，虚拟机发起一次MinorGC。  
大对象直接进去老年代，大对象是指需要连续大量内存空间的java对象，典型的有很长的字符串和数组。应该尽量避免其实。  
长期存活的对象 进入老年代。虚拟机有年龄计数器，可以通过maxtenuringthreshold来设置进入老年代年龄。如果在survivor空间相同年龄所有对象大小总和大于survivor空间的一半，年龄大于等一该年龄的对象都可以直接进入老年代，而不用等到maxtenuringthreshold。 


# 虚拟机类加载机制
## 类加载生命周期：
类从加载到虚拟机内存开始，到卸载出内存为止，他的整个生命周期包括：加载，验证，准备，解析，初始化，使用，卸载七个阶段，其中验证，准备，解析统称为连接。其中解析并非按步骤开始，可能在初始化后再开始，这些步骤的顺序是开始而非必须上一步完成后再进行。    
加载虚拟机并没有做强制的约束，而初始化有严格的约束：
1.遇到new getstatic putstatic invokestatic 这个4个字节码命令时，如果类没有初始化则初始化。  
2.使用java.lang.reflect包方法进行发射调用时，如果类没有初始化则初始化。  
3.当初始化一个类时其父类没有初始化，则需要先初始化其父类  
4.虚拟机启动时，用户指定了一个要执行的主类（包含main），虚拟机先初始化这个类。   
## 类加载过程：
### 加载：虚拟机加载要完成三件事  
1.通过类的全限定名来获取定义此类的二进制字节流  
2.将这些字节流所代表的静态存储结构化为方法区的运行时数据结构  
3.在java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口  
而上面二进制流的获取非常灵活，不一定是class文件，也要很多获取途径，包括jar、war、网络获取（applet）、运行时计算生成（动态代理）、其他文件（jsp）、数据库中读取。。等等   
### 验证：
文件格式验证：验证字节流是否符合class文件格式规范，并且能不当前虚拟机版本处理。如：主次版本号是否在当前虚拟机处理范围、是否魔术0XCAFEBABE开头、常量池常量是否不被支持格式等等   
元数据验证：对字节码描述信息进行语义分析，以保证其描述信息符合java语言规范。如：这个类是否有父类，这个类是否继承了不能继承的类    
字节码验证：进行数据流和控制流分析，保证被校验的类的方法运行时不会做出危害虚拟机安全的行为。如：保证跳转指令不会跳转到方法体以外的字节码命令上。  
符号引用验证：对类本身以外的信息进行匹配验证，如：符号引用通过字符串描述的全限定名是否能找到对应的类等    
### 准备：
正式为类变量分配内存空间并设置类变量初始值的阶段。这些内存将在方法区中被分配。
解析：解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，对应于常量池的CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_MethodRef_info, CONSTANT_InterfaceMethodref_info.    
### 初始化：初始化阶段是执行类的构造器<clinit>()方法的过程

## 类加载器与类 
类加载器虽然只用于实现类的加载动作，但被广泛运用于类层次划分、OSGI、热部署、代码加密等领域。只要同一个类用不同的类加载器加载哪这个两个类必定不相等。这里只的相等是Class对象的equals方法，isAssignableFrom（）方法，isInstance方法的返回结果。     
### 双亲委派模型：
站在虚拟机的角度只有两种不同的类加载器：启动类加载器（C++实现，虚拟机的一部分，加载）和其他的类加载器（java实现集成java.lang.classLoader）
站在开发者角度：
启动类加载器：负责将java_home\lib下的、或者被-Xbootclasspath参数所指定的路径中的并且是虚拟识别的类库（按照文件名识别，如rt.jar，名字不符合的类库即使放在lib中也没用）加载到虚拟机内存中，启动类加载器无法在java程序中被直接引用。   
扩展类加载器：负责加载java_home\lib\ext目录中或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
应用程序类加载器：由于这个类加载器是ClassLoader中的getSystemClassLoader方法的返回值，所以也称系统类加载器。负责加载用户类路径所指定的类库，开发者可以使用这个类加载器，如果没有自定义过类加载器，这个就是一般程序中默认的类加载器。    
双亲委派模式：如果一个类加载器收到了类加载的请求，首先会请求父类加载器去完成，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载才会尝试自己去加载。   
破坏双亲委派机制：第一次破坏是JDK1.2之前，没有发生双亲委派机制，JDK1.2以后就不提倡用户再去覆盖loadClass。而应该把自己的类加载器逻辑写的findclass方法中，在loadclass方法的逻辑中，如果父类加载失败则会调用自己的findClass方法来完成加载，这样就能保证新写出来的类加载器符合双亲委派规则。    
第二次：双亲委派机制解决了各个类加载器的基础类统一的问题，但是如果基础类要调回用户代码呢？一个典型的列子就是JNDI。JNDI是java的标准服务，由启动类加载器加载，JNDI的目的是对资源进行整合和查找，他需要调用独立厂商实现并部署咋应用程序的JNDI接口提供者，java引入了一个线程上下文类加载器。   
第三次：是热部署，子OSGI下不在试双亲委派机制的树状结构。

# 高效并发
Java内存模型与线程:java虚拟机定义了java的内存模型来屏蔽掉各种硬件和操作系统的内存访问差异。以实现java程序在各种平台下都能达到一致的并发效果。   
当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行。也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的。这个可以说是绝对线程安全。    
Java的线程安全：不可变的对象一定是线程安全的。   
相对线程安全：它需要保证这个对象单独的操作是线程安全的，但在一些特定的顺序调用就可能需要在调用端使用额外的同步手段来保证调用的正确性。  
线程兼容：线程本身并不是线程安全的，但是而已通过在调用端正确的使用同步手段来保证对在并发的环境中安全使用。  
线程对立：线程对立是指不关调用端是否采取了同步措施，都无法在多线程的环境下并发使用代码。  
## 线程安全的实现：  
### 1.互斥同步
互斥是因同步是果，最基本的互斥同步手段是synchronize关键字，synchronize同步快在同一线程中是可重入的，不会锁死自己，java线程时映射到操作系统原生线程之上的，如果阻塞和唤醒一条线程都需要操作系统完成，这需要从用户态转换到核心态。所以耗费的时间长，是一个重量级操作。    
除了synchronize还有重入锁reentrantLock，功能基本相同不过增加了可中断，实现公平锁，以及可以绑定多个条件。两者的性能上jdk1.6之后就差不多了    
### 2.非阻塞同步
互斥同步的问题是阻塞和唤醒所带来的性能问题，因此也成为阻塞同步，非阻塞同步，基于冲突检测的乐观并发策略，通俗的说是先进行操作，如果没其他线程共享数据那就操作成功了，如果有，产生了冲突，再进行其他补偿措施。    
这种需要cas的支持，所以对硬件有要求，且是jdk1.5以后才提供的Unsafe类，这个类提供给用户使用，只有启动类加载器加载的类才能访问他，但是我们可以通过反射手段拿到。   
### 3.无同步方案
不多解释，就是无需同步。
