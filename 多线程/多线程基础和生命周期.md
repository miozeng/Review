# 多线程
### 线程的主要用途
①、利用它可以完成重复性的工作（如实现动画、声音等的播放）。     
②、从事一次性较费时的初始化工作（如网络连接、声音数据文件的加载）。     
③、并发执行的运行效果（一个进程多个线程）以实现更复杂的功能     
我的理解就是，不影响整个程序的进程，程序接着往下走，线程默默的把自己这部分工作再做完。有点片面。    

### 多线程（多个线程同时运行）程序的主要优点
①、可以减轻系统性能方面的瓶颈，因为可以并行操作；     
②、提高CPU的处理器的效率，在多线程中，通过优先级管理，可以使重要的程序优先操作，提高了任务管理的灵活性；另一方面，在多CPU系统中，可以把不同的线程在不同的CPU中执行，真正做到同时处理多任务。       
注意：
①、在继承Thread的方式中，可以使用getName()方法，来获得当前线程的名字，这是因为在Thread类中，有这个方法。可是在实现Runnable方式中，却不可以使用this.getName()，因为Runnable接口没有这个方法（可以看出来，因为我们没有提示我们需要重写这个方法），所以只能通过Thread的静态方法 Thread.currentThread()取得当前的Thread对象，在调用getName()方法，来取得当前线程的名字。    
②、对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。只有调用start()方法才会启动新线程。      

### 两种方式的对比
采用实现Runnable接口方式的多线程具有优势，一般都会使用这种方式：
1、线程类只是实现了Runnable接口，还可以继承其他类。
2、在这种方式下，可以多个线程共享一个Runnable target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。

# 线程的生命周期
### 1、新建状态
用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。
注意：不能对已经启动的线程再次调用start()方法，否则会出现java.lang.IllegalThreadStateException异常。

### 2、就绪状态
处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），
等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。
一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。

### 3、运行状态
处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。
也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。
当发生如下情况是，线程会从运行状态变为阻塞状态：     
①、线程调用sleep方法主动放弃所占用的系统资源    
②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞   
③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有  
④、线程在等待某个通知（notify）   
⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。  
当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。


### 4、阻塞状态
处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 
在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。

### 5、死亡状态
当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。



# 线程状态的控制
Java提供了一些便捷的方法用于会线程状态的控制。   
interrupt()中断线程。.join()等待该线程终止。  
join(long millis) 等待该线程终止的时间最长为 millis 毫秒。  
join(long millis, int nanos) 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。  
setDaemon(boolean on) 将该线程标记为守护线程或用户线程。  
setPriority(int newPriority) 更改线程的优先级。  
setPriority(int newPriority) 更改线程的优先级。   
sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。   
sleep(long millis, int nanos) 在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。   
start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。   
yield() 暂停当前正在执行的线程对象，并执行其他线程。   

### 1、线程睡眠——sleep
如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法  
注意如下几点问题    
①、sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。看下面的例子：
``` java
public class Test1 {  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println(Thread.currentThread().getName());  
        MyThread myThread=new MyThread();  
        myThread.start();  
        myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程  
        Thread.sleep(10);  
        for(int i=0;i<100;i++){  
            System.out.println("main"+i);  
        }  
    }  
}  
```
②、Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。

### 2、线程让步——yield
yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。

实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。

关于sleep()方法和yield()方的区别如下：
①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。
②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。
③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。
### 3、线程合并——join
join线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。从上面的方法的列表可以看到，它有3个重载的方法：void join()        当前线程等该加入该线程后面，等待该线程终止。    void join(long millis)        当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   void join(long millis,int nanos)        等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  例子：
``` java
public class Test1 {  
    public static void main(String[] args) throws InterruptedException {  
        MyThread thread=new MyThread();  
        thread.start();  
        thread.join(1);//将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  
        for(int i=0;i<30;i++){  
            System.out.println(Thread.currentThread().getName() + "线程第" + i + "次执行！");  
        }  
    }  
}  
  
class MyThread extends Thread {  
    @Override  
    public void run() {  
        for (int i = 0; i < 1000; i++) {  
            System.out.println(this.getName() + "线程第" + i + "次执行！");  
        }  
    }  
}  
``` 
在这个例子中，在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。
### 4、线程的优先级
每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。
每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。
Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~·0之间，也可以使用Thread类提供的三个静态常量：
MAX_PRIORITY   =10
MIN_PRIORITY   =1
NORM_PRIORITY   =5
例子：
``` java
public class Test1 {  
    public static void main(String[] args) throws InterruptedException {  
        new MyThread("高级", 10).start();  
        new MyThread("低级", 1).start();  
    }  
}  
  
class MyThread extends Thread {  
    public MyThread(String name,int pro) {  
        super(name);//设置线程的名称  
        setPriority(pro);//设置线程的优先级  
    }  
    @Override  
    public void run() {  
        for (int i = 0; i < 100; i++) {  
            System.out.println(this.getName() + "线程第" + i + "次执行！");  
        }  
    }  
}  
``` 
从结果可以看到 ，一般情况下，高级线程更显执行完毕。
注意一点：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。
所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。

### 5.守护线程
守护线程与普通线程写法上基本么啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。
守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，
连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。
守护线程的用途：
守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。Java的垃圾回收也是一个守护线程。守护线
的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，
不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了


### 6、如何结束一个线程
Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。
1、正常执行完run方法，然后结束掉
2、控制循环条件和判断条件的标识符来结束掉线程
3、使用interrupt结束一个线程。
